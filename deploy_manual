import os
import logging
import shutil
import paramiko
import socket
import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
from threading import Thread, Event
from concurrent.futures import ThreadPoolExecutor

# Configuration
DEFAULT_SOURCE_FOLDER = r'C:\Source\ETPStoreFrontV5.5'
HOST_USER = 'linuxadmin'
HOST_PASS = 'St0re@dm1n'
TILL_USER = 'posuser'
TILL_PASS = 'till@123'
TILL_START_OCTET = 111
TILL_DEST_BASE = '/home/posuser/ETPSuite/ETPStoreFrontV5.5'
HOST_DEST = '/home/linuxadmin/ETPStoreFrontV5.5'
TIMEOUT_CONNECT = 5
TIMEOUT_TRANSFER = 10
MAX_WORKERS = 5

SOURCE_FOLDER = DEFAULT_SOURCE_FOLDER

class DeploymentGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ETP Deployment Tool v3.2")
        self.root.geometry("750x600")
        self.root.resizable(False, False)

        self.source_folder = tk.StringVar(value=DEFAULT_SOURCE_FOLDER)
        self.config_file = tk.StringVar(value='deployment_config.xlsx')
        self.manual_host_ip = tk.StringVar()
        self.manual_till_nums = tk.StringVar()
        self.stop_event = Event()
        self.is_running = False
        self.logger = None
        self.excel_log = None
        self.last_results_file = None
        self.total_tasks = 0
        self.completed_tasks = 0

        self.setup_ui()
        self.setup_logging()

    def setup_ui(self):
        # Source Folder
        tk.Label(self.root, text="Source Folder:").pack(pady=8)
        source_frame = tk.Frame(self.root)
        source_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(source_frame, textvariable=self.source_folder, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(source_frame, text="Browse", command=self.browse_source).pack(side=tk.RIGHT, padx=5)

        # Config File
        tk.Label(self.root, text="Config File (Full Mode):").pack(pady=8)
        config_frame = tk.Frame(self.root)
        config_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(config_frame, textvariable=self.config_file, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(config_frame, text="Browse", command=self.browse_config).pack(side=tk.RIGHT, padx=5)

        # Manual / Restart Section
        manual_frame = tk.LabelFrame(self.root, text="Manual / Restart Failed", padx=15, pady=15)
        manual_frame.pack(pady=15, fill=tk.X, padx=20)

        tk.Label(manual_frame, text="Host IP (Manual only):").grid(row=0, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_host_ip, width=35).grid(row=0, column=1, padx=10, pady=5)

        tk.Label(manual_frame, text="Tills (comma sep):").grid(row=1, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_till_nums, width=35).grid(row=1, column=1, padx=10, pady=5)

        btn_frame = tk.Frame(manual_frame)
        btn_frame.grid(row=2, column=0, columnspan=2, pady=10)

        self.manual_btn = tk.Button(btn_frame, text="Manual Deploy", command=self.start_manual,
                                    bg='purple', fg='white', width=15)
        self.manual_btn.pack(side=tk.LEFT, padx=10)

        # Main Action Buttons
        main_btn_frame = tk.Frame(self.root)
        main_btn_frame.pack(pady=15)

        self.start_btn = tk.Button(main_btn_frame, text="Start Full Deployment", command=self.start_full_deployment,
                                   bg='green', fg='white', width=20)
        self.start_btn.pack(side=tk.LEFT, padx=10)

        self.restart_failed_btn = tk.Button(main_btn_frame, text="Restart on Failed Tills", command=self.start_restart_failed,
                                            bg='orange', fg='white', width=22)
        self.restart_failed_btn.pack(side=tk.LEFT, padx=10)

        self.stop_btn = tk.Button(main_btn_frame, text="Stop", command=self.stop_operation,
                                  bg='red', fg='white', width=10, state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=10)

        # Progress
        self.progress = ttk.Progressbar(self.root, mode='determinate', length=600)
        self.progress.pack(pady=10, padx=20)

        self.progress_label = tk.Label(self.root, text="0% Complete", font=("Arial", 12))
        self.progress_label.pack(pady=5)

        # Status
        self.status_label = tk.Label(self.root, text="Ready", relief=tk.SUNKEN, anchor=tk.W, bg="lightgray")
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X, pady=(0,10), padx=10)

        # Log
        tk.Label(self.root, text="Live Log:", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=20, pady=5)
        self.log_text = scrolledtext.ScrolledText(self.root, height=10, font=("Consolas", 9))
        self.log_text.pack(pady=5, padx=20, fill=tk.BOTH, expand=True)

    def setup_logging(self):
        self.log_filename = f'deployment_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
        logging.basicConfig(filename=self.log_filename, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

        # Custom GUI handler
        class GuiHandler(logging.Handler):
            def __init__(self, text_widget):
                super().__init__()
                self.text_widget = text_widget

            def emit(self, record):
                msg = self.format(record)
                self.text_widget.insert(tk.END, msg + '\n')
                self.text_widget.see(tk.END)

        gui_handler = GuiHandler(self.log_text)
        gui_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(gui_handler)

    def browse_source(self):
        folder = filedialog.askdirectory(initialdir=self.source_folder.get())
        if folder:
            self.source_folder.set(folder)

    def browse_config(self):
        file = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if file:
            self.config_file.set(file)

    def disable_buttons(self):
        self.start_btn.config(state=tk.DISABLED)
        self.restart_failed_btn.config(state=tk.DISABLED)
        self.manual_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)

    def enable_buttons(self):
        self.start_btn.config(state=tk.NORMAL)
        self.restart_failed_btn.config(state=tk.NORMAL)
        self.manual_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)

    def start_full_deployment(self):
        if self.is_running:
            return

        source = self.source_folder.get()
        config = self.config_file.get()

        if not os.path.exists(source) or not os.path.isdir(source):
            messagebox.showerror("Error", "Invalid source folder!")
            return
        if not os.path.exists(config):
            messagebox.showerror("Error", "Config file not found!")
            return

        global SOURCE_FOLDER
        SOURCE_FOLDER = source

        try:
            df = pd.read_excel(config)
            hosts = [(str(row['HostIP']).strip(), int(row['MaxTill'])) for _, row in df.iterrows()]
        except Exception as e:
            messagebox.showerror("Error", f"Invalid config:\n{e}")
            return

        self.total_tasks = len(hosts)
        self.completed_tasks = 0
        self.is_running = True
        self.disable_buttons()
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text="Full Deployment Running...")

        self.deployment_thread = Thread(target=self.run_full_deployment, args=(hosts,))
        self.deployment_thread.daemon = True
        self.deployment_thread.start()

    def run_full_deployment(self, hosts):
        def process_host(ip, max_till):
            if self.stop_event.is_set():
                return
            try:
                success = self.deploy_to_host(ip, max_till)
                self.completed_tasks += 1
                self.root.after(0, lambda: self.update_progress(self.completed_tasks))
            except Exception as e:
                self.logger.error(f"Host {ip} failed: {e}")

        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            executor.map(lambda args: process_host(*args), hosts)

        self.root.after(0, self.operation_complete)

    def deploy_to_host(self, host_ip, max_till):
        self.logger.info(f"Deploying to host {host_ip} ({max_till} tills)")
        transport = connect_transport(host_ip, HOST_USER, HOST_PASS, TIMEOUT_CONNECT, logger=self.logger)
        if not transport:
            return False

        try:
            sftp = paramiko.SFTPClient.from_transport(transport)
            upload_folder(sftp, SOURCE_FOLDER, HOST_DEST, self.logger)
            self.logger.info(f"Host upload success: {host_ip}")
            return True
        except Exception as e:
            self.logger.error(f"Host {host_ip} upload failed: {e}")
            return False
        finally:
            try:
                sftp.close()
                transport.close()
            except:
                pass

    def start_restart_failed(self):
        if self.is_running:
            messagebox.showwarning("Warning", "Another operation is running.")
            return

        if not self.last_results_file or not os.path.exists(self.last_results_file):
            messagebox.showerror("Error", "No previous deployment log found.\nRun a full deployment first.")
            return

        try:
            df = pd.read_excel(self.last_results_file)
            failed = df[df['Status'] == 'Failure'][['TillIP']].drop_duplicates()
            if failed.empty:
                messagebox.showinfo("Info", "No failed tills found in the last log.")
                return
        except Exception as e:
            messagebox.showerror("Error", f"Cannot read last log:\n{e}")
            return

        failed_tills = failed['TillIP'].tolist()

        self.total_tasks = len(failed_tills)
        self.completed_tasks = 0

        self.is_running = True
        self.disable_buttons()
        self.stop_btn.config(state=tk.NORMAL)
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text=f"Restarting {len(failed_tills)} failed tills...")

        self.restart_thread = Thread(target=self.run_restart_failed, args=(failed_tills,))
        self.restart_thread.daemon = True
        self.restart_thread.start()

    def run_restart_failed(self, failed_tills):
        reattempt_results = []

        for till_ip in failed_tills:
            if self.stop_event.is_set():
                self.logger.info("Restart stopped by user.")
                break

            self.logger.info(f"Restarting failed till: {till_ip}")
            success = self.direct_upload_to_till(till_ip)

            status = "Reattempt Success" if success else "Reattempt Failure"
            self.logger.info(f"{till_ip} â†’ {status}")

            reattempt_results.append({'TillIP': till_ip, 'Status': status})

            self.completed_tasks += 1
            self.root.after(0, lambda: self.update_progress(self.completed_tasks))

        # Save reattempt log
        if reattempt_results:
            reattempt_file = f"reattempt_failed_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
            pd.DataFrame(reattempt_results).to_excel(reattempt_file, index=False)
            self.logger.info(f"Reattempt log saved: {reattempt_file}")

        self.root.after(0, self.operation_complete)

    def direct_upload_to_till(self, till_ip):
        transport = connect_transport(till_ip, TILL_USER, TILL_PASS, TIMEOUT_CONNECT, logger=self.logger)
        if not transport:
            return False

        try:
            transport.sock.settimeout(TIMEOUT_TRANSFER)
            sftp = paramiko.SFTPClient.from_transport(transport)

            try:
                sftp.stat(TILL_DEST_BASE)
            except FileNotFoundError:
                parent = os.path.dirname(TILL_DEST_BASE)
                sftp.mkdir(parent)
                sftp.mkdir(TILL_DEST_BASE)

            upload_folder(sftp, SOURCE_FOLDER, TILL_DEST_BASE, self.logger)
            return True
        except Exception as e:
            self.logger.error(f"Upload failed to {till_ip}: {e}")
            return False
        finally:
            try:
                sftp.close()
                transport.close()
            except:
                pass

    def start_manual(self):
        messagebox.showinfo("Manual", "Manual direct deployment is not implemented yet in this version.")

    def operation_complete(self):
        self.is_running = False
        self.enable_buttons()
        self.stop_btn.config(state=tk.DISABLED)
        self.progress['value'] = 100
        self.progress_label.config(text="100% Complete")
        self.status_label.config(text="Operation Finished")
        self.logger.info("Operation completed.")

    def stop_operation(self):
        self.stop_event.set()
        self.status_label.config(text="Stopping...")

# Helper functions
def connect_transport(host, username, password, timeout, port=22, logger=None):
    if not logger:
        logger = logging.getLogger()
    logger.info(f"Connecting to {host}...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        transport = paramiko.Transport(sock)
        transport.start_client(timeout=timeout)
        transport.auth_password(username, password)
        transport.set_keepalive(30)
        return transport
    except Exception as e:
        logger.error(f"Connect failed {host}: {e}")
        return None
    finally:
        sock.close()

def upload_folder(sftp, local_dir, remote_dir, logger):
    try:
        sftp.mkdir(remote_dir)
    except:
        pass
    for item in os.listdir(local_dir):
        local = os.path.join(local_dir, item)
        remote = f"{remote_dir}/{item}"
        if os.path.isdir(local):
            upload_folder(sftp, local, remote, logger)
        else:
            sftp.put(local, remote)

if __name__ == "__main__":
    root = tk.Tk()
    app = DeploymentGUI(root)
    root.mainloop()