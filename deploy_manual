import os
import logging
import paramiko
import socket
import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
from threading import Thread, Event
from concurrent.futures import ThreadPoolExecutor

# Configuration
DEFAULT_SOURCE_FOLDER = r'C:\Source\ETPStoreFrontV5.5'
HOST_USER = 'linuxadmin'
HOST_PASS = 'St0re@dm1n'
TILL_USER = 'posuser'
TILL_PASS = 'till@123'
TILL_START_OCTET = 111
TILL_DEST_BASE = '/home/posuser/ETPSuite/ETPStoreFrontV5.5'
HOST_DEST = '/home/linuxadmin/ETPStoreFrontV5.5'
TIMEOUT_CONNECT = 5
TIMEOUT_TRANSFER = 10
MAX_WORKERS = 5  # Max simultaneous host connections

SOURCE_FOLDER = DEFAULT_SOURCE_FOLDER

class DeploymentGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ETP Deploy Tool")
        self.root.geometry("700x550")
        self.root.resizable(False, False)

        self.source_folder = tk.StringVar(value=DEFAULT_SOURCE_FOLDER)
        self.config_file = tk.StringVar(value='deployment_config.xlsx')
        self.manual_host_ip = tk.StringVar()
        self.manual_till_nums = tk.StringVar()
        self.stop_event = Event()
        self.is_running = False
        self.logger = None

        self.setup_ui()
        self.setup_logging()

    def setup_ui(self):
        # Source Folder
        tk.Label(self.root, text="Source Folder:").pack(pady=8)
        source_frame = tk.Frame(self.root)
        source_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(source_frame, textvariable=self.source_folder, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(source_frame, text="Browse", command=self.browse_source).pack(side=tk.RIGHT, padx=5)

        # Config File (for full mode)
        tk.Label(self.root, text="Config File (for Full Mode):").pack(pady=8)
        config_frame = tk.Frame(self.root)
        config_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(config_frame, textvariable=self.config_file, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(config_frame, text="Browse", command=self.browse_config).pack(side=tk.RIGHT, padx=5)

        # Manual Section
        manual_frame = tk.LabelFrame(self.root, text="Manual Till Deployment", padx=15, pady=15)
        manual_frame.pack(pady=15, fill=tk.X, padx=20)

        tk.Label(manual_frame, text="Host IP (e.g. 10.0.70.12):").grid(row=0, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_host_ip, width=35).grid(row=0, column=1, padx=10, pady=5)

        tk.Label(manual_frame, text="Tills (e.g. 1,3,4):").grid(row=1, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_till_nums, width=35).grid(row=1, column=1, padx=10, pady=5)

        self.manual_btn = tk.Button(manual_frame, text="Manual Deploy", command=self.start_manual,
                                    bg='purple', fg='white', width=20)
        self.manual_btn.grid(row=2, column=0, columnspan=2, pady=15)

        # Main Buttons
        button_frame = tk.Frame(self.root)
        button_frame.pack(pady=10)

        self.start_btn = tk.Button(button_frame, text="Start Full Deployment", command=self.start_full_deployment,
                                   bg='green', fg='white', width=20)
        self.start_btn.pack(side=tk.LEFT, padx=10)

        self.stop_btn = tk.Button(button_frame, text="Stop", command=self.stop_operation,
                                  bg='red', fg='white', width=10, state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=10)

        # Progress
        self.progress = ttk.Progressbar(self.root, mode='determinate', length=600)
        self.progress.pack(pady=10, padx=20)

        self.progress_label = tk.Label(self.root, text="0% Complete", font=("Arial", 12))
        self.progress_label.pack(pady=5)

        # Log Area
        tk.Label(self.root, text="Live Log:", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=20, pady=5)
        self.log_text = scrolledtext.ScrolledText(self.root, height=10, font=("Consolas", 9))
        self.log_text.pack(pady=5, padx=20, fill=tk.BOTH, expand=True)

    def setup_logging(self):
        self.log_filename = f'deployment_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
        logging.basicConfig(filename=self.log_filename, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

        class GuiLogHandler(logging.Handler):
            def emit(self, record):
                msg = self.format(record)
                self.log_text.insert(tk.END, msg + '\n')
                self.log_text.see(tk.END)

        gui_handler = GuiLogHandler()
        gui_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(gui_handler)

    def browse_source(self):
        folder = filedialog.askdirectory(initialdir=self.source_folder.get())
        if folder:
            self.source_folder.set(folder)

    def browse_config(self):
        file = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx *.xls")])
        if file:
            self.config_file.set(file)

    def disable_buttons(self):
        self.start_btn.config(state=tk.DISABLED)
        self.manual_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)

    def enable_buttons(self):
        self.start_btn.config(state=tk.NORMAL)
        self.manual_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)

    def start_full_deployment(self):
        if self.is_running:
            return

        source = self.source_folder.get()
        config = self.config_file.get()

        if not os.path.exists(source):
            messagebox.showerror("Error", "Source folder not found!")
            return
        if not os.path.exists(config):
            messagebox.showerror("Error", "Config file not found!")
            return

        global SOURCE_FOLDER
        SOURCE_FOLDER = source

        try:
            df = pd.read_excel(config)
            hosts = [(row['HostIP'].strip(), int(row['MaxTill'])) for _, row in df.iterrows()]
        except Exception as e:
            messagebox.showerror("Error", f"Invalid config file:\n{e}")
            return

        self.total_tasks = len(hosts)
        self.completed_tasks = 0
        self.is_running = True
        self.disable_buttons()
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text="Full Deployment Running...")

        self.deployment_thread = Thread(target=self.run_full_deployment, args=(hosts,))
        self.deployment_thread.daemon = True
        self.deployment_thread.start()

    def run_full_deployment(self, hosts):
        def process_host(host_ip, max_till):
            if self.stop_event.is_set():
                return False
            try:
                self.logger.info(f"Processing host {host_ip} with {max_till} tills")
                success = self.deploy_to_host(host_ip, max_till)
                self.completed_tasks += 1
                self.root.after(0, lambda: self.update_progress(self.completed_tasks))
                return success
            except Exception as e:
                self.logger.error(f"Host {host_ip} failed: {e}")
                return False

        with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = [executor.submit(process_host, ip, tills) for ip, tills in hosts]
            for future in futures:
                if self.stop_event.is_set():
                    break
                future.result()  # Wait and handle exceptions

        self.root.after(0, self.operation_complete)

    def deploy_to_host(self, host_ip, max_till):
        prefix = '.'.join(host_ip.split('.')[:3])
        till_ips = [f"{prefix}.{TILL_START_OCTET + i}" for i in range(1, max_till + 1)]

        transport = connect_transport(host_ip, HOST_USER, HOST_PASS, TIMEOUT_CONNECT, logger=self.logger)
        if not transport:
            return False

        try:
            sftp = paramiko.SFTPClient.from_transport(transport)
            upload_folder(sftp, SOURCE_FOLDER, HOST_DEST, self.logger)
            self.logger.info(f"Host upload complete: {host_ip}")
            return True
        except Exception as e:
            self.logger.error(f"Upload to host {host_ip} failed: {e}")
            return False
        finally:
            try:
                sftp.close()
                transport.close()
            except:
                pass

    def start_manual(self):
        if self.is_running:
            return

        host_ip = self.manual_host_ip.get().strip()
        till_str = self.manual_till_nums.get().strip()

        if not host_ip or not till_str:
            messagebox.showerror("Input Error", "Host IP and Till numbers are required!")
            return

        try:
            till_nums = [int(x.strip()) for x in till_str.split(',') if x.strip()]
        except:
            messagebox.showerror("Input Error", "Invalid till numbers! Use comma-separated numbers.")
            return

        prefix = '.'.join(host_ip.split('.')[:3])
        till_ips = [f"{prefix}.{TILL_START_OCTET + n}" for n in till_nums]

        self.total_tasks = len(till_ips)
        self.completed_tasks = 0

        self.is_running = True
        self.disable_buttons()
        self.stop_btn.config(state=tk.NORMAL)
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text=f"Manual Deployment ({len(till_ips)} tills)...")

        self.manual_thread = Thread(target=self.run_manual, args=(till_ips,))
        self.manual_thread.daemon = True
        self.manual_thread.start()

    def run_manual(self, till_ips):
        for till_ip in till_ips:
            if self.stop_event.is_set():
                self.logger.info("Manual deployment stopped.")
                break

            success = self.direct_upload_to_till(till_ip)
            self.completed_tasks += 1
            self.root.after(0, lambda: self.update_progress(self.completed_tasks))

        self.root.after(0, self.operation_complete)

    def direct_upload_to_till(self, till_ip):
        transport = connect_transport(till_ip, TILL_USER, TILL_PASS, TIMEOUT_CONNECT, logger=self.logger)
        if not transport:
            return False

        try:
            transport.sock.settimeout(TIMEOUT_TRANSFER)
            sftp = paramiko.SFTPClient.from_transport(transport)

            try:
                sftp.stat(TILL_DEST_BASE)
            except FileNotFoundError:
                parent = os.path.dirname(TILL_DEST_BASE)
                sftp.mkdir(parent)
                sftp.mkdir(TILL_DEST_BASE)

            upload_folder(sftp, SOURCE_FOLDER, TILL_DEST_BASE, self.logger)
            self.logger.info(f"Success: Uploaded to {till_ip}")
            return True
        except Exception as e:
            self.logger.error(f"Failed {till_ip}: {e}")
            return False
        finally:
            try:
                sftp.close()
                transport.close()
            except:
                pass

    def operation_complete(self):
        self.is_running = False
        self.enable_buttons()
        self.stop_btn.config(state=tk.DISABLED)
        self.progress['value'] = 100
        self.progress_label.config(text="100% Complete")
        self.status_label.config(text="Operation Completed")
        self.logger.info("Operation finished.")

    def stop_operation(self):
        self.stop_event.set()
        self.status_label.config(text="Stopping...")

# Helpers
def connect_transport(host, username, password, timeout, port=22, logger=None):
    if not logger:
        logger = logging.getLogger()
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        transport = paramiko.Transport(sock)
        transport.start_client(timeout=timeout)
        transport.auth_password(username, password)
        return transport
    except Exception as e:
        logger.error(f"Connect failed {host}: {e}")
        return None

def upload_folder(sftp, local_dir, remote_dir, logger):
    try:
        sftp.mkdir(remote_dir)
    except:
        pass
    for item in os.listdir(local_dir):
        local = os.path.join(local_dir, item)
        remote = f"{remote_dir}/{item}"
        if os.path.isdir(local):
            upload_folder(sftp, local, remote, logger)
        else:
            sftp.put(local, remote)
            logger.debug(f"Uploaded: {item}")

if __name__ == "__main__":
    root = tk.Tk()
    app = DeploymentGUI(root)
    root.mainloop()