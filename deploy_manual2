import os
import logging
import shutil
import paramiko
import socket
import pandas as pd
from stat import S_ISDIR
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
from threading import Thread, Event
from concurrent.futures import ProcessPoolExecutor, as_completed
from multiprocessing import freeze_support

# Configuration - Adjust as needed
DEFAULT_SOURCE_FOLDER = r'C:\Source\ETPStoreFrontV5.5'
HOST_USER = 'linuxadmin'
HOST_PASS = 'St0re@dm1n'  # Confirmed as per your message
TILL_USER = 'posuser'
TILL_PASS = 'till@123'
TILL_START_OCTET = 111  # Till1 -> .112, Till2 -> .113, etc. (111 + till_num)
TILL_DEST_BASE = '/home/posuser/ETPSuite/ETPStoreFrontV5.5'  # As per requirement
HOST_DEST = '/home/linuxadmin/ETPStoreFrontV5.5'  # Fixed for hosts
TIMEOUT_CONNECT = 3  # Seconds for connection attempts
TIMEOUT_TRANSFER = 6  # Approximate for transfer operations (paramiko timeouts)
MAX_WORKERS = 5  # Number of concurrent hosts to process (adjust based on network capacity)

SOURCE_FOLDER = DEFAULT_SOURCE_FOLDER  # Global, set dynamically

# Required for multiprocessing on Windows
if __name__ == '__main__':
    freeze_support()

# ========================
# TOP-LEVEL PROCESS-SAFE FUNCTIONS
# ========================
def connect_transport(host, username, password, timeout, port=22):
    logger = logging.getLogger('deploy_process')
    logger.info(f"[PROCESS] Connecting to {host}...")
    sock = None
    transport = None
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        transport = paramiko.Transport(sock)
        transport.start_client(timeout=timeout)
        transport.auth_password(username, password)
        transport.set_keepalive(30)
        return transport
    except Exception as e:
        logger.error(f"[PROCESS] Connect failed {host}: {e}")
        return None
    finally:
        if sock:
            try:
                sock.close()
            except:
                pass

def upload_folder(sftp, local_dir, remote_dir, logger):
    try:
        sftp.mkdir(remote_dir)
    except:
        pass
    for item in os.listdir(local_dir):
        local = os.path.join(local_dir, item)
        remote = f"{remote_dir}/{item}"
        if os.path.isdir(local):
            upload_folder(sftp, local, remote, logger)
        else:
            sftp.put(local, remote)

def deploy_to_host_process(host_ip, max_till):
    logger = logging.getLogger('deploy_process')
    logger.info(f"[PROCESS] Deploying to {host_ip} ({max_till} tills)")

    transport = connect_transport(host_ip, HOST_USER, HOST_PASS, TIMEOUT_CONNECT)
    if not transport:
        return False, f"Connection failed: {host_ip}"

    sftp = None
    try:
        sftp = paramiko.SFTPClient.from_transport(transport)
        upload_folder(sftp, SOURCE_FOLDER, HOST_DEST, logger)
        logger.info(f"[PROCESS] Upload success for {host_ip}")
        return True, f"Success: {host_ip}"
    except Exception as e:
        logger.error(f"[PROCESS] Upload failed {host_ip}: {e}")
        return False, f"Failed: {host_ip} - {str(e)}"
    finally:
        try:
            if sftp:
                sftp.close()
            if transport:
                transport.close()
        except:
            pass

def is_port_reachable(host, port, timeout, logger):
    """Check if the host's port is reachable within timeout."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    try:
        result = sock.connect_ex((host, port))
        sock.close()
        if result == 0:
            logger.debug(f"Port {port} on {host} is reachable")
            return True
        else:
            logger.warning(f"Port {port} on {host} is not reachable (error code: {result})")
            return False
    except socket.timeout:
        logger.error(f"Timeout while checking port {port} on {host}")
        return False
    except Exception as e:
        logger.error(f"Error checking port {port} on {host}: {str(e)}")
        return False

def copy_dir_between_sfpts(sftp_src, sftp_dest, src_dir, dst_dir, logger):
    """Recursively copy directory contents from one SFTP to another. Overwrites existing files; does not delete extras."""
    try:
        attrs = sftp_src.listdir_attr(src_dir)
    except Exception as e:
        logger.error(f"Cannot list source directory {src_dir}: {str(e)}")
        return

    try:
        sftp_dest.stat(dst_dir)
        logger.debug(f"Destination {dst_dir} exists")
    except FileNotFoundError:
        sftp_dest.mkdir(dst_dir)
        logger.info(f"Created destination directory: {dst_dir}")
    except Exception as e:
        logger.error(f"Cannot access/create destination {dst_dir}: {str(e)}")
        return

    for attr in attrs:
        if attr.filename.startswith('.'):
            continue  # Skip hidden files
        src_item = f"{src_dir}/{attr.filename}"
        dst_item = f"{dst_dir}/{attr.filename}"
        try:
            if S_ISDIR(attr.st_mode):
                copy_dir_between_sfpts(sftp_src, sftp_dest, src_item, dst_item, logger)
            else:
                # Stream copy without temp files; overwrites if exists
                with sftp_src.open(src_item, 'rb') as fr:
                    with sftp_dest.open(dst_item, 'wb') as fw:
                        shutil.copyfileobj(fr, fw)
                logger.debug(f"Copied {attr.filename}")
        except Exception as e:
            logger.error(f"Failed to copy {attr.filename}: {str(e)}")
            # Continue to next item

def delete_remote_folder(sftp, remote_dir, logger):
    """Recursively delete a remote directory and its contents."""
    try:
        attrs = sftp.listdir_attr(remote_dir)
    except Exception as e:
        logger.warning(f"Cannot list remote directory {remote_dir} for deletion: {str(e)}")
        return

    for attr in attrs:
        if attr.filename.startswith('.'):
            continue  # Skip hidden files
        item = f"{remote_dir}/{attr.filename}"
        try:
            if S_ISDIR(attr.st_mode):
                delete_remote_folder(sftp, item, logger)
            else:
                sftp.remove(item)
                logger.debug(f"Deleted file: {attr.filename}")
        except Exception as e:
            logger.error(f"Failed to delete {item}: {str(e)}")
            # Continue to next item

    try:
        sftp.rmdir(remote_dir)
        logger.info(f"Deleted directory: {remote_dir}")
    except Exception as e:
        logger.error(f"Failed to delete directory {remote_dir}: {str(e)}")

# ========================
# GUI CLASS
# ========================
class DeploymentGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ETP Deployment Tool v3.6 - ProcessPool Final")
        self.root.geometry("750x650")
        self.root.resizable(False, False)

        self.source_folder = tk.StringVar(value=DEFAULT_SOURCE_FOLDER)
        self.config_file = tk.StringVar(value='deployment_config.xlsx')
        self.manual_host_ip = tk.StringVar()
        self.manual_till_nums = tk.StringVar()
        self.stop_event = Event()
        self.is_running = False
        self.logger = None
        self.excel_log = None
        self.last_results_file = None
        self.total_tasks = 0
        self.completed_tasks = 0

        self.setup_ui()
        self.setup_logging()

    def setup_ui(self):
        tk.Label(self.root, text="Source Folder:").pack(pady=8)
        source_frame = tk.Frame(self.root)
        source_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(source_frame, textvariable=self.source_folder, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(source_frame, text="Browse", command=self.browse_source).pack(side=tk.RIGHT, padx=5)

        tk.Label(self.root, text="Config File (Full Mode):").pack(pady=8)
        config_frame = tk.Frame(self.root)
        config_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(config_frame, textvariable=self.config_file, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(config_frame, text="Browse", command=self.browse_config).pack(side=tk.RIGHT, padx=5)

        manual_frame = tk.LabelFrame(self.root, text="Manual Deployment", padx=15, pady=15)
        manual_frame.pack(pady=15, fill=tk.X, padx=20)

        tk.Label(manual_frame, text="Host IP:").grid(row=0, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_host_ip, width=35).grid(row=0, column=1, padx=10, pady=5)

        tk.Label(manual_frame, text="Tills (comma sep):").grid(row=1, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_till_nums, width=35).grid(row=1, column=1, padx=10, pady=5)

        self.manual_btn = tk.Button(manual_frame, text="Manual Deploy", command=self.start_manual,
                                    bg='purple', fg='white', width=15)
        self.manual_btn.grid(row=2, column=0, columnspan=2, pady=10)

        main_btn_frame = tk.Frame(self.root)
        main_btn_frame.pack(pady=15)

        self.start_btn = tk.Button(main_btn_frame, text="Start Full Deployment", command=self.start_full_deployment,
                                   bg='green', fg='white', width=20)
        self.start_btn.pack(side=tk.LEFT, padx=10)

        self.restart_failed_btn = tk.Button(main_btn_frame, text="Restart on Failed Tills", command=self.start_restart_failed,
                                            bg='orange', fg='white', width=22)
        self.restart_failed_btn.pack(side=tk.LEFT, padx=10)

        self.stop_btn = tk.Button(main_btn_frame, text="Stop", command=self.stop_operation,
                                  bg='red', fg='white', width=10, state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=10)

        self.progress = ttk.Progressbar(self.root, mode='determinate', length=600)
        self.progress.pack(pady=10, padx=20)

        self.progress_label = tk.Label(self.root, text="0% Complete", font=("Arial", 12))
        self.progress_label.pack(pady=5)

        self.status_label = tk.Label(self.root, text="Ready", relief=tk.SUNKEN, anchor=tk.W, bg="lightgray")
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X, pady=(0,10), padx=10)

        tk.Label(self.root, text="Live Log:", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=20, pady=5)
        self.log_text = scrolledtext.ScrolledText(self.root, height=10, font=("Consolas", 9))
        self.log_text.pack(pady=5, padx=20, fill=tk.BOTH, expand=True)

    def setup_logging(self):
        self.log_filename = f'deployment_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
        logging.basicConfig(filename=self.log_filename, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

        class GuiHandler(logging.Handler):
            def __init__(self, text_widget):
                super().__init__()
                self.text_widget = text_widget

            def emit(self, record):
                msg = self.format(record)
                self.text_widget.insert(tk.END, msg + '\n')
                self.text_widget.see(tk.END)

        gui_handler = GuiHandler(self.log_text)
        gui_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(gui_handler)

    def browse_source(self):
        folder = filedialog.askdirectory(initialdir=self.source_folder.get())
        if folder:
            self.source_folder.set(folder)

    def browse_config(self):
        file = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if file:
            self.config_file.set(file)

    def disable_buttons(self):
        self.start_btn.config(state=tk.DISABLED)
        self.restart_failed_btn.config(state=tk.DISABLED)
        self.manual_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)

    def enable_buttons(self):
        self.start_btn.config(state=tk.NORMAL)
        self.restart_failed_btn.config(state=tk.NORMAL)
        self.manual_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)

    def start_full_deployment(self):
        if self.is_running:
            return

        source = self.source_folder.get()
        config = self.config_file.get()

        if not os.path.exists(source) or not os.path.isdir(source):
            messagebox.showerror("Error", "Invalid source folder!")
            return
        if not os.path.exists(config):
            messagebox.showerror("Error", "Config file not found!")
            return

        global SOURCE_FOLDER
        SOURCE_FOLDER = source

        try:
            df = pd.read_excel(config)
            hosts = [(str(row['HostIP']).strip(), int(row['MaxTill'])) for _, row in df.iterrows()]
        except Exception as e:
            messagebox.showerror("Error", f"Invalid config:\n{e}")
            return

        self.total_tasks = len(hosts)
        self.completed_tasks = 0
        self.is_running = True
        self.disable_buttons()
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text="Full Deployment Running (Multiprocess)...")

        self.deployment_thread = Thread(target=self.run_full_deployment, args=(hosts,))
        self.deployment_thread.daemon = True
        self.deployment_thread.start()

    def run_full_deployment(self, hosts):
        with ProcessPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = [executor.submit(deploy_to_host_process, ip, max_till) for ip, max_till in hosts]

            for future in as_completed(futures):
                if self.stop_event.is_set():
                    self.logger.info("Deployment interrupted by user")
                    break
                success, msg = future.result()
                self.completed_tasks += 1
                self.logger.info(msg)
                self.root.after(0, lambda: self.update_progress(self.completed_tasks))

        self.root.after(0, self.operation_complete)

    def update_progress(self, completed):
        if self.total_tasks == 0:
            return
        percent = (completed / self.total_tasks) * 100
        self.progress['value'] = percent
        self.progress_label.config(text=f"{int(percent)}% Complete")

    def operation_complete(self):
        self.is_running = False
        self.enable_buttons()
        self.stop_btn.config(state=tk.DISABLED)
        self.progress['value'] = 100
        self.progress_label.config(text="100% Complete")
        self.status_label.config(text="Operation Finished")
        self.logger.info("Operation completed.")

    def stop_operation(self):
        self.stop_event.set()
        self.status_label.config(text="Stopping...")

    def start_restart_failed(self):
        if self.is_running:
            messagebox.showwarning("Warning", "Another operation is running.")
            return

        if not self.last_results_file or not os.path.exists(self.last_results_file):
            messagebox.showerror("Error", "No previous deployment log found.\nRun full deployment first.")
            return

        try:
            df = pd.read_excel(self.last_results_file)
            failed = df[df['Status'] == 'Failure'][['HostIP', 'TillIP']].drop_duplicates()
            if failed.empty:
                messagebox.showinfo("Info", "No failed tills to reattempt.")
                return
            self.total_hosts = len(failed)  # Treat as "total tasks" for progress
        except Exception as e:
            messagebox.showerror("Error", f"Failed to read results: {str(e)}")
            return

        self.is_reattempting = True
        self.reattempt_btn.config(state=tk.DISABLED)
        self.stop_event.clear()
        self.start_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text="Reattempting Failed Tills...")

        self.reattempt_thread = Thread(target=self.run_reattempt, args=(failed,))
        self.reattempt_thread.daemon = True
        self.reattempt_thread.start()

    def start_manual(self):
        messagebox.showinfo("Manual", "Manual deployment not implemented yet.")

if __name__ == '__main__':
    freeze_support()
    root = tk.Tk()
    app = DeploymentGUI(root)
    root.mainloop()
