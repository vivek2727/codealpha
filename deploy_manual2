import os
import logging
import shutil
import paramiko
import socket
import pandas as pd
from datetime import datetime
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
from threading import Thread, Event
from concurrent.futures import ProcessPoolExecutor, as_completed
from multiprocessing import freeze_support

# ========================
# CONFIGURATION
# ========================
DEFAULT_SOURCE_FOLDER = r'C:\Source\ETPStoreFrontV5.5'
HOST_USER = 'linuxadmin'
HOST_PASS = 'St0re@dm1n'
TILL_USER = 'posuser'
TILL_PASS = 'till@123'
TILL_START_OCTET = 111
TILL_DEST_BASE = '/home/posuser/ETPSuite/ETPStoreFrontV5.5'
HOST_DEST = '/home/linuxadmin/ETPStoreFrontV5.5'
TIMEOUT_CONNECT = 5
TIMEOUT_TRANSFER = 10
MAX_WORKERS = 5  # Increase if your PC can handle it

SOURCE_FOLDER = DEFAULT_SOURCE_FOLDER

# Required for multiprocessing on Windows
if __name__ == '__main__':
    freeze_support()

# ========================
# TOP-LEVEL PROCESS-SAFE FUNCTION
# ========================
def deploy_to_host_process(host_ip, max_till):
    """
    This function runs in a separate process.
    It must not rely on any instance variables or local closures.
    """
    logger = logging.getLogger('deploy_process')
    logger.info(f"[PROCESS] Starting deployment to host {host_ip} ({max_till} tills)")

    try:
        transport = connect_transport(host_ip, HOST_USER, HOST_PASS, TIMEOUT_CONNECT)
        if not transport:
            logger.error(f"[PROCESS] Connection failed to {host_ip}")
            return False, f"Connection failed: {host_ip}"

        sftp = paramiko.SFTPClient.from_transport(transport)
        upload_folder(sftp, SOURCE_FOLDER, HOST_DEST, logger)
        logger.info(f"[PROCESS] Upload success for host {host_ip}")
        return True, f"Success: {host_ip}"

    except Exception as e:
        logger.error(f"[PROCESS] Error on host {host_ip}: {e}")
        return False, f"Failed: {host_ip} - {str(e)}"

    finally:
        try:
            if 'sftp' in locals():
                sftp.close()
            if 'transport' in locals():
                transport.close()
        except Exception as cleanup_e:
            logger.warning(f"Cleanup error: {cleanup_e}")

# ========================
# GUI CLASS
# ========================
class DeploymentGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("ETP Deployment Tool v3.4 - ProcessPool Fixed")
        self.root.geometry("750x650")
        self.root.resizable(False, False)

        self.source_folder = tk.StringVar(value=DEFAULT_SOURCE_FOLDER)
        self.config_file = tk.StringVar(value='deployment_config.xlsx')
        self.manual_host_ip = tk.StringVar()
        self.manual_till_nums = tk.StringVar()
        self.stop_event = Event()
        self.is_running = False
        self.logger = None
        self.last_results_file = None
        self.total_tasks = 0
        self.completed_tasks = 0

        self.setup_ui()
        self.setup_logging()

    def setup_ui(self):
        tk.Label(self.root, text="Source Folder:").pack(pady=8)
        source_frame = tk.Frame(self.root)
        source_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(source_frame, textvariable=self.source_folder, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(source_frame, text="Browse", command=self.browse_source).pack(side=tk.RIGHT, padx=5)

        tk.Label(self.root, text="Config File (Full Mode):").pack(pady=8)
        config_frame = tk.Frame(self.root)
        config_frame.pack(pady=5, fill=tk.X, padx=20)
        tk.Entry(config_frame, textvariable=self.config_file, width=60).pack(side=tk.LEFT, fill=tk.X, expand=True)
        tk.Button(config_frame, text="Browse", command=self.browse_config).pack(side=tk.RIGHT, padx=5)

        manual_frame = tk.LabelFrame(self.root, text="Manual Deployment", padx=15, pady=15)
        manual_frame.pack(pady=15, fill=tk.X, padx=20)

        tk.Label(manual_frame, text="Host IP:").grid(row=0, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_host_ip, width=35).grid(row=0, column=1, padx=10, pady=5)

        tk.Label(manual_frame, text="Tills (comma sep):").grid(row=1, column=0, sticky=tk.W, pady=5)
        tk.Entry(manual_frame, textvariable=self.manual_till_nums, width=35).grid(row=1, column=1, padx=10, pady=5)

        self.manual_btn = tk.Button(manual_frame, text="Manual Deploy", command=self.start_manual,
                                    bg='purple', fg='white', width=15)
        self.manual_btn.grid(row=2, column=0, columnspan=2, pady=10)

        main_btn_frame = tk.Frame(self.root)
        main_btn_frame.pack(pady=15)

        self.start_btn = tk.Button(main_btn_frame, text="Start Full Deployment", command=self.start_full_deployment,
                                   bg='green', fg='white', width=20)
        self.start_btn.pack(side=tk.LEFT, padx=10)

        self.restart_failed_btn = tk.Button(main_btn_frame, text="Restart on Failed Tills", command=self.start_restart_failed,
                                            bg='orange', fg='white', width=22)
        self.restart_failed_btn.pack(side=tk.LEFT, padx=10)

        self.stop_btn = tk.Button(main_btn_frame, text="Stop", command=self.stop_operation,
                                  bg='red', fg='white', width=10, state=tk.DISABLED)
        self.stop_btn.pack(side=tk.LEFT, padx=10)

        self.progress = ttk.Progressbar(self.root, mode='determinate', length=600)
        self.progress.pack(pady=10, padx=20)

        self.progress_label = tk.Label(self.root, text="0% Complete", font=("Arial", 12))
        self.progress_label.pack(pady=5)

        self.status_label = tk.Label(self.root, text="Ready", relief=tk.SUNKEN, anchor=tk.W, bg="lightgray")
        self.status_label.pack(side=tk.BOTTOM, fill=tk.X, pady=(0,10), padx=10)

        tk.Label(self.root, text="Live Log:", font=("Arial", 10, "bold")).pack(anchor=tk.W, padx=20, pady=5)
        self.log_text = scrolledtext.ScrolledText(self.root, height=10, font=("Consolas", 9))
        self.log_text.pack(pady=5, padx=20, fill=tk.BOTH, expand=True)

    def setup_logging(self):
        self.log_filename = f'deployment_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log'
        logging.basicConfig(filename=self.log_filename, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.logger = logging.getLogger(__name__)

        class GuiHandler(logging.Handler):
            def __init__(self, text_widget):
                super().__init__()
                self.text_widget = text_widget

            def emit(self, record):
                msg = self.format(record)
                self.text_widget.insert(tk.END, msg + '\n')
                self.text_widget.see(tk.END)

        gui_handler = GuiHandler(self.log_text)
        gui_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(gui_handler)

    def browse_source(self):
        folder = filedialog.askdirectory(initialdir=self.source_folder.get())
        if folder:
            self.source_folder.set(folder)

    def browse_config(self):
        file = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if file:
            self.config_file.set(file)

    def disable_buttons(self):
        self.start_btn.config(state=tk.DISABLED)
        self.restart_failed_btn.config(state=tk.DISABLED)
        self.manual_btn.config(state=tk.DISABLED)
        self.stop_btn.config(state=tk.NORMAL)

    def enable_buttons(self):
        self.start_btn.config(state=tk.NORMAL)
        self.restart_failed_btn.config(state=tk.NORMAL)
        self.manual_btn.config(state=tk.NORMAL)
        self.stop_btn.config(state=tk.DISABLED)

    def start_full_deployment(self):
        if self.is_running:
            return

        source = self.source_folder.get()
        config = self.config_file.get()

        if not os.path.exists(source) or not os.path.isdir(source):
            messagebox.showerror("Error", "Invalid source folder!")
            return
        if not os.path.exists(config):
            messagebox.showerror("Error", "Config file not found!")
            return

        global SOURCE_FOLDER
        SOURCE_FOLDER = source

        try:
            df = pd.read_excel(config)
            hosts = [(str(row['HostIP']).strip(), int(row['MaxTill'])) for _, row in df.iterrows()]
        except Exception as e:
            messagebox.showerror("Error", f"Invalid config:\n{e}")
            return

        self.total_tasks = len(hosts)
        self.completed_tasks = 0
        self.is_running = True
        self.disable_buttons()
        self.stop_event.clear()
        self.progress['value'] = 0
        self.progress_label.config(text="0% Complete")
        self.status_label.config(text="Full Deployment Running (Multiprocess)...")

        self.deployment_thread = Thread(target=self.run_full_deployment, args=(hosts,))
        self.deployment_thread.daemon = True
        self.deployment_thread.start()

    def run_full_deployment(self, hosts):
        def process_host_wrapper(args):
            return deploy_to_host_process(*args)

        with ProcessPoolExecutor(max_workers=MAX_WORKERS) as executor:
            futures = [executor.submit(process_host_wrapper, (ip, max_till)) for ip, max_till in hosts]

            for future in as_completed(futures):
                if self.stop_event.is_set():
                    self.logger.info("Deployment interrupted by user")
                    break
                success, msg = future.result()
                self.completed_tasks += 1
                self.logger.info(msg)
                self.root.after(0, lambda: self.update_progress(self.completed_tasks))

        self.root.after(0, self.operation_complete)

    def update_progress(self, completed):
        if self.total_tasks == 0:
            return
        percent = (completed / self.total_tasks) * 100
        self.progress['value'] = percent
        self.progress_label.config(text=f"{int(percent)}% Complete")

    def operation_complete(self):
        self.is_running = False
        self.enable_buttons()
        self.stop_btn.config(state=tk.DISABLED)
        self.progress['value'] = 100
        self.progress_label.config(text="100% Complete")
        self.status_label.config(text="Operation Finished")
        self.logger.info("Operation completed.")

    def stop_operation(self):
        self.stop_event.set()
        self.status_label.config(text="Stopping...")

    def start_restart_failed(self):
        messagebox.showinfo("Info", "Restart on failed tills feature - coming soon in next update.")

    def start_manual(self):
        messagebox.showinfo("Manual", "Manual deployment - coming soon.")

# ========================
# PROCESS-SAFE HELPERS (MUST BE TOP-LEVEL)
# ========================
def connect_transport(host, username, password, timeout, port=22):
    logger = logging.getLogger('deploy_process')
    logger.info(f"[PROCESS] Connecting to {host}...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        transport = paramiko.Transport(sock)
        transport.start_client(timeout=timeout)
        transport.auth_password(username, password)
        transport.set_keepalive(30)
        return transport
    except Exception as e:
        logger.error(f"[PROCESS] Connect failed {host}: {e}")
        return None
    finally:
        if 'sock' in locals():
            sock.close()

def upload_folder(sftp, local_dir, remote_dir, logger):
    try:
        sftp.mkdir(remote_dir)
    except:
        pass
    for item in os.listdir(local_dir):
        local = os.path.join(local_dir, item)
        remote = f"{remote_dir}/{item}"
        if os.path.isdir(local):
            upload_folder(sftp, local, remote, logger)
        else:
            sftp.put(local, remote)

if __name__ == '__main__':
    root = tk.Tk()
    app = DeploymentGUI(root)
    root.mainloop()