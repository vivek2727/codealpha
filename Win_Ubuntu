import paramiko
import socket
import time
import os  # Added for local folder handling

# ==== CONFIG ====
USERNAME = "posuser"
PASSWORD = "till@123"

SOURCE_FOLDER = "/home/posuser/ETPStoreFrontV5.5"  # Remote path on source till where we upload
DEST_FOLDER = "/home/posuser/ETPSuite"  # Destination on all tills (including source)

LOCAL_FOLDER = r"C:\Source\ETPStoreFrontV5.5"  # Local Windows path; use r'' for raw string to handle backslashes
# Alternatively, make it dynamic: LOCAL_FOLDER = input("Enter local folder path (e.g., C:\\Source\\ETPStoreFrontV5.5): ").strip()

# Get base IP from user input
full_ip = input("Enter base IP (e.g. 10.2.12.12): ").strip()

# Split IP and validate
ip_parts = full_ip.split(".")
if len(ip_parts) != 4 or not all(part.isdigit() and 0 <= int(part) <= 255 for part in ip_parts):
    print("❌ Invalid IP format. Please enter like 10.2.12.12")
    exit()

# Form base IP using first 3 octets
base_ip = ".".join(ip_parts[:3]) + "."

# Get starting octet from input
start_octet = int(ip_parts[3])

# Get number of tills from user input
num_tills = int(input("Enter number of tills: ").strip())

# Generate list of IPs from starting octet
ALL_TILLS = [f"{base_ip}{start_octet + i}" for i in range(num_tills)]

# First is source, all (including source) are targets
SOURCE_TILL = ALL_TILLS[0]
TARGET_TILLS = ALL_TILLS[0:]  # Includes source till, as requested

# Show the result
print("\n✅ Generated Tills:")
print("Source Till:", SOURCE_TILL)
print("Target Tills:", TARGET_TILLS)
print()

# ==== FUNCTION TO CONNECT WITH TIMEOUT ====
def ssh_connect(ip, timeout=10):
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        client.connect(ip, username=USERNAME, password=PASSWORD, timeout=timeout)
        return client
    except (paramiko.AuthenticationException, paramiko.SSHException, socket.error, socket.timeout):
        return None

# ==== FUNCTION TO UPLOAD DIRECTORY RECURSIVELY VIA SFTP ====
def upload_directory(sftp, local_dir, remote_dir):
    try:
        # Create remote dir if it doesn't exist
        try:
            sftp.stat(remote_dir)
        except FileNotFoundError:
            sftp.mkdir(remote_dir)
        
        for item in os.listdir(local_dir):
            local_path = os.path.join(local_dir, item)
            remote_path = remote_dir + '/' + item  # Use '/' for remote paths
            if os.path.isdir(local_path):
                upload_directory(sftp, local_path, remote_path)
            else:
                sftp.put(local_path, remote_path)
                print(f"📤 Uploaded file: {local_path} to {remote_path}")
    except Exception as e:
        raise Exception(f"Upload failed: {str(e)}")

# ==== MAIN SCRIPT ====
print("🚀 Starting File Transfer Automation...\n")

# Step 1: Connect to Till 1 (source)
print(f"🔐 Connecting to Till 1 ({SOURCE_TILL})...")
source_client = ssh_connect(SOURCE_TILL)
if not source_client:
    print(f"❌ Could not connect to Till 1 ({SOURCE_TILL}). Exiting.")
    exit()

print("✅ Connected to Till 1.")

# Step 1.5: Upload local folder to source till via SFTP
print(f"📂 Uploading local folder {LOCAL_FOLDER} to {SOURCE_FOLDER} on Till 1...")
try:
    sftp = source_client.open_sftp()
    upload_directory(sftp, LOCAL_FOLDER, SOURCE_FOLDER)
    sftp.close()
    print("✅ Upload to Till 1 completed.\n")
except Exception as e:
    print(f"❌ Upload failed: {str(e)}. Exiting.")
    source_client.close()
    exit()

# Step 2: Check if source folder exists on Till 1 (optional after upload, but kept for verification)
print(f"📂 Checking if source folder exists: {SOURCE_FOLDER}")
stdin, stdout, stderr = source_client.exec_command(f"ls {SOURCE_FOLDER}")
if "No such file" in stderr.read().decode():
    print(f"❌ Source folder {SOURCE_FOLDER} not found on Till 1.")
    source_client.close()
    exit()
else:
    print("✅ Source folder found on Till 1.\n")

# Step 3: Transfer to each target till (including source)
for till in TARGET_TILLS:
    print(f"➡️ Processing Till {till} ...")

    # Check if till is reachable
    print(f"🔌 Trying to connect to {till} (10 sec timeout)...")
    target_client = ssh_connect(till, timeout=3)

    if not target_client:
        print(f"❌ Till {till} not in network. Skipping.\n")
        continue
    print(f"✅ Till {till} is reachable.")

    # Run scp from Till 1 to this target till
    scp_cmd = f"scp -r {SOURCE_FOLDER} {USERNAME}@{till}:{DEST_FOLDER}"
    print(f"📤 Executing: {scp_cmd}")
    stdin, stdout, stderr = source_client.exec_command(scp_cmd, get_pty=True)

    # Provide password for scp authentication
    stdin.write(PASSWORD + "\n")
    stdin.flush()

    # Wait for completion
    exit_status = stdout.channel.recv_exit_status()
    if exit_status == 0:
        print(f"✅ Successfully copied folder to Till {till}\n")
    else:
        error_msg = stderr.read().decode()
        print(f"❌ Failed to copy to Till {till}. Error: {error_msg}\n")

    target_client.close()

# Step 4: Close source connection
source_client.close()
print("🎉 File Transfer Completed for all tills.")